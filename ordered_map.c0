#use <conio>
#use <string>
#use <util>

/*
    This file contains a ordered map implemented with red-black tree.
*/

// BEGIN `om_node_t` definitions

/*
    Introducing the worst implementation of polymorphism in the history of
    computer science create by me at 3 a.m. after a week of sleep deprivation.

    So basically just create a injective function from any type to `om_key_t`
    and use the functions in this file to make a map with your type as keys. The
    output type is always an integer though, as it is easy to create a mapping
    to your own type at a covariant position, but not at a contravariant
    position.

    Note: an `om_key_t *` passed into `om_insert_kv_pair` is not copied.
    Therefore an `om_key_t` should never be mutated after its creation.
*/
struct om_key_t {
    int key_size;
    int[] key;
};
typedef struct om_key_t om_key_t;

struct om_node_t {
    om_key_t *key;
    int value;

    struct om_node_t *left;
    struct om_node_t *right;
    struct om_node_t *parent;

    bool is_red; // false = black; true = red
};
typedef struct om_node_t om_node_t;

struct om_map_t {
    int size;
    om_node_t *root;

    bool allow_repeat;
};
typedef struct om_map_t om_map_t;

// END `om_node_t` definitions

// BEGIN contract functions

/*
    Sanity check for checking that the children of a node has parent pointing
    to the node.
 */
bool __om_fully_connected(om_node_t *node, om_node_t *parent) {
    if (node == NULL) return true;
    if (node->parent != parent) return false;
    return __om_fully_connected(node->left, node)
        || __om_fully_connected(node->right, node);
}

/*
    In order to bypass pureness restriction of contract functions:
    - returns -1 if there exists non-matching height in descendents
    - returns black height (n >= 0) if subtrees are valid
 */
int __om_valid_node_height(om_node_t *node) {
    if (node == NULL) {
        return 1;
    }

    int l_height = __om_valid_node_height(node->left);
    int r_height = __om_valid_node_height(node->right);

    if (l_height == -1 || r_height == -1) {
        return -1;
    }

    if (l_height != r_height) return -1;

    return node->is_red ? l_height : l_height + 1;
}

bool __om_no_consecutive_red(om_node_t *node, bool is_parent_red) {
    if (node == NULL) return true;
    if (node->is_red && is_parent_red) return false;
    return __om_no_consecutive_red(node->left, node->is_red)
        && __om_no_consecutive_red(node->right, node->is_red);
}

bool __om_is_valid_tree(om_map_t *tree)
//@requires tree != NULL;
{
    // empty tree is fine
    if (tree->root == NULL) return true;
    
    // root is black
    if (tree->root->is_red) return false;
    
    // no consecutive red nodes && equal-size black path
    return __om_fully_connected(tree->root, NULL)
        && __om_no_consecutive_red(tree->root, false)
        && __om_valid_node_height(tree->root) != -1;
}

// END contract functions

// BEGIN forward declarations

void om_print_kv_pair(om_node_t *kv);

// END forward declarations

// BEGIN utilities functions

om_node_t *__om_get_uncle(om_node_t *node)
//@requires node != NULL;
//@requires node->parent != NULL;
//@requires node->parent->parent != NULL;
{
    om_node_t *parent = node->parent;
    om_node_t *grand = parent->parent;
    return grand->left == parent ? grand->right : grand->left;
}

om_node_t *__om_get_sibling(om_node_t *node)
//@requires node != NULL;
//@requires node->parent != NULL;
{
    om_node_t *parent = node->parent;
    return parent->left == node ? parent->right : parent->left;
}

// END utilities functions

// BEGIN constructor

om_map_t *om_create_map()
//@ensures __om_is_valid_tree(\result);
{
    om_map_t *map = alloc(om_map_t);
    map->size = 0;
    map->root = NULL;
    map->allow_repeat = false;
    return map;
}

om_map_t *om_create_bst()
//@ensures __om_is_valid_tree(\result);
{
    om_map_t *map = alloc(om_map_t);
    map->root = NULL;
    map->allow_repeat = true;
    return map;
}

// END constructor

// BEGIN serialization functions

om_key_t *om_serialize_int(int value)
//@ensures \result->key_size == 1;
{
    om_key_t *key = alloc(om_key_t);
    key->key_size = 1;
    key->key = alloc_array(int, 1);
    key->key[0] = value;

    return key;
}

om_key_t *om_serialize_string(string value)
//@ensures string_length(value) == \result->key_size;
{
    om_key_t *key = alloc(om_key_t);
    key->key_size = string_length(value);
    key->key = alloc_array(int, key->key_size);
    for (int i = 0; i < key->key_size; i++) {
        key->key[i] = char_ord(string_charat(value, i));
    }

    return key;
}

int om_compare_key(om_key_t *a, om_key_t *b)
//@ensures -1 <= \result && \result <= 1;
{
    for (int i = 0; i < min(a->key_size, b->key_size); i++) {
        if (a->key[i] < b->key[i]) return -1;
        else if (a->key[i] > b->key[i]) return 1;
    }

    if (a->key_size == b->key_size) return 0;
    else if (a->key_size < b->key_size) return -1;
    else return 1;
}

// END serialization functions

// BEGIN rotations

void left_rotate(om_map_t *tree, om_node_t *node)
//@requires node->right != NULL;
{
    om_node_t *right = node->right;
    node->right = right->left;
    if (node->right != NULL) node->right->parent = node;

    right->parent = node->parent;

    if (node->parent == NULL) tree->root = right;
    else if (node->parent->left == node) node->parent->left = right;
    else node->parent->right = right;

    node->parent = right;
    right->left = node;
}

void right_rotate(om_map_t *tree, om_node_t *node)
//@requires node->left != NULL;
{
    om_node_t *left = node->left;
    node->left = left->right;
    if (node->left != NULL) node->left->parent = node;

    left->parent = node->parent;

    if (node->parent == NULL) tree->root = left;
    else if (node->parent->left == node) node->parent->left = left;
    else node->parent->right = left;

    node->parent = left;
    left->right = node;
}

// END rotations

om_node_t *om_find_node(om_node_t *node, om_key_t *key) {
    while (node != NULL) {
        int cmp = om_compare_key(key, node->key);
        if (cmp == 0) return node;
        else if (cmp < 0) node = node->left;
        else node = node->right;
    }

    return NULL;
}

bool om_has_key(om_map_t *tree, om_key_t *key)
//@requires __om_is_valid_tree(tree);
{
    return om_find_node(tree->root, key) != NULL;
}

// https://www.geeksforgeeks.org/insertion-in-red-black-tree/
void om_recolor_or_rotate(om_map_t *tree, om_node_t *node) {
    while (node->parent != NULL && node->parent->is_red) {
        om_node_t *parent = node->parent;
        om_node_t *grand = parent->parent;
        //@assert grand != NULL; // since a red node cannot be root node
        //@assert parent == grand->left || parent == grand->right;

        om_node_t *uncle = __om_get_uncle(node);
        if (uncle != NULL && uncle->is_red) {
            /*
                - change parent and uncle to black
                - repeat `om_recolor_or_rotate` on grandfather
            */
            parent->is_red = false;
            uncle->is_red = false;
            grand->is_red = true;
            node = grand;
        } else {
            /*
                four possible cases:
                - LL rotation
                - LR rotation
                - RR rotation
                - RL rotation
            */

            if (node == parent->left && parent == grand->left) {
                // LL case
                right_rotate(tree, grand);
                bool parent_red = parent->is_red;
                parent->is_red = grand->is_red;
                grand->is_red = parent_red;

            } else if (node == parent->right && parent == grand->left) {
                // LR case
                left_rotate(tree, parent);
                right_rotate(tree, grand);
                bool grand_red = grand->is_red;
                grand->is_red = node->is_red;
                node->is_red = grand_red;

            } else if (node == parent->right && parent == grand->right) {
                // RR case
                left_rotate(tree, grand);
                bool grand_red = grand->is_red;
                grand->is_red = parent->is_red;
                parent->is_red = grand_red;

            } else if (node == parent->left && parent == grand->right) {
                // RL case
                right_rotate(tree, parent);
                left_rotate(tree, grand);
                bool grand_red = grand->is_red;
                grand->is_red = node->is_red;
                node->is_red = grand_red;
            } else {
                // SHOULD BE UNREACHABLE.
                //@assert 0 == 1;
            }
        }
    }

    tree->root->is_red = false;
}

void om_insert_kv_pair(om_map_t *tree, om_key_t *key, int value)
//@requires __om_is_valid_tree(tree);
//@ensures __om_is_valid_tree(tree);
{
    om_node_t *new_node = alloc(om_node_t);
    new_node->is_red = true;
    new_node->key = key;
    new_node->value = value;
    
    if (tree->root == NULL) {
        new_node->is_red = false;
        tree->root = new_node;
        tree->size++;
    } else {
        om_node_t *parent = NULL;
        om_node_t *curr = tree->root;
        bool last_branch_is_left = false;
        while (curr != NULL) {
            parent = curr;
            int cmp = om_compare_key(key, curr->key);
            if (cmp == 0 && !tree->allow_repeat) {
                curr->value = value;
                return;
            } else if (cmp < 0) {
                curr = curr->left;
                last_branch_is_left = true;
            } else {
                curr = curr->right;
                last_branch_is_left = false;
            }
        }

        if (last_branch_is_left) parent->left = new_node;
        else parent->right = new_node;
        new_node->parent = parent;
        tree->size++;

        om_recolor_or_rotate(tree, new_node);
    }
}

void om_insert_s(om_map_t *tree, string key, int value)
//@requires __om_is_valid_tree(tree);
//@ensures __om_is_valid_tree(tree);
{
    om_insert_kv_pair(tree, om_serialize_string(key), value);
}

void om_insert_i(om_map_t *tree, int key, int value)
//@requires __om_is_valid_tree(tree);
//@ensures __om_is_valid_tree(tree);
{
    om_insert_kv_pair(tree, om_serialize_int(key), value);
}

int om_get_s(om_map_t *tree, string key)
//@requires __om_is_valid_tree(tree);
//@ensures __om_is_valid_tree(tree);
{
    return om_find_node(tree->root, om_serialize_string(key))->value;
}

int om_get_i(om_map_t *tree, int key)
//@requires __om_is_valid_tree(tree);
//@ensures __om_is_valid_tree(tree);
{
    return om_find_node(tree->root, om_serialize_int(key))->value;
}

om_node_t *om_get_leftmost(om_node_t *root)
//@requires root != NULL;
//@ensures \result != NULL;
{
    while (root->left != NULL) {
        root = root->left;
    }

    return root;
}

om_node_t *om_del_find_replace(om_node_t *node)
//@requires node != NULL;
{
    if (node->left == NULL && node->right == NULL) {
        return NULL;
    } else if (node->left == NULL || node->right == NULL) {
        return node->left != NULL ? node->left : node->right;
    } else {
        return om_get_leftmost(node->right);
    }
}

void __om_reduce_double_black(om_map_t *tree, om_node_t *node) {
    // only used in the loop guard to test for continuation
    om_node_t *flag = node;
    while (flag != NULL && flag != tree->root) {
        // default: stop after this iteration
        node = flag;
        flag = NULL;

        //@assert node->parent != NULL;
        om_node_t *parent = node->parent;
        om_node_t *sibling = __om_get_sibling(node);
        
        if (sibling == NULL) {
            flag = parent;
        } else {
            if (sibling->is_red) {
                parent->is_red = true;
                sibling->is_red = false;

                if (parent->left == sibling) right_rotate(tree, parent);
                else left_rotate(tree, parent);

                flag = node;
            } else {
                if (sibling->left != NULL && sibling->left->is_red) {
                    // left children is red

                    if (sibling == parent->left) {
                        // LL case

                        sibling->left->is_red = sibling->is_red;
                        sibling->is_red = parent->is_red;
                        right_rotate(tree, parent);
                    } else {
                        // RL case

                        sibling->left->is_red = parent->is_red;
                        right_rotate(tree, sibling);
                        left_rotate(tree, parent);
                    }

                    parent->is_red = false;

                } else if (sibling->right != NULL && sibling->right->is_red) {
                    // right children is red

                    if (sibling == parent->left) {
                        // LR case

                        sibling->right->is_red = parent->is_red;
                        left_rotate(tree, sibling);
                        right_rotate(tree, parent);
                    } else {
                        // RR case

                        sibling->right->is_red = sibling->is_red;
                        sibling->is_red = parent->is_red;
                        left_rotate(tree, parent);
                    }

                    parent->is_red = false;

                } else {
                    // both children are black

                    sibling->is_red = true;
                    if (parent->is_red) parent->is_red = false;
                    else flag = parent;
                }
            }
        }
    }
}

// https://www.geeksforgeeks.org/deletion-in-red-black-tree/
void om_delete_node(om_map_t *tree, om_node_t *v)
//@requires v != NULL;
{
    om_node_t *u = om_del_find_replace(v);
    bool both_black = (u == NULL || !u->is_red) && !v->is_red;

    if (v->left == NULL && v->right == NULL) {
        // deleting a leaf node

        //@assert u == NULL;
        if (v == tree->root) {
            //@assert tree->size == 1;

            tree->root = NULL;
            tree->size--;
        } else {
            if (both_black) {
                __om_reduce_double_black(tree, v);
            } else {
                // make sibling red
                om_node_t *sibling = __om_get_sibling(v);
                if (sibling != NULL) sibling->is_red = true;
            }

            // delete `v`
            //@assert v->parent != NULL;
            if (v->parent->left == v) v->parent->left = NULL;
            else v ->parent->right = NULL;
            tree->size--;
        }

    } else if (v->left == NULL || v->right == NULL) {
        // deleting a node with one children

        if (v == tree->root) {
            //@assert tree->size == 2;

            v->key = u->key;
            v->value = u->value;
            v->left = NULL;
            v->right = NULL;
            tree->size--;
        } else {
            // remove `v` and replace it with `u`
            u->parent = v->parent;
            if (v->parent->left == v) v->parent->left = u;
            else v->parent->right = u;
            tree->size--;

            if (both_black) {
                __om_reduce_double_black(tree, u);
            } else {
                //@assert u->is_red || v->is_red;
                u->is_red = false;
            }
        }

    } else {
        // internal node

        //@assert v->left != NULL && v->right != NULL;
        om_key_t *temp_key = v->key;
        int temp_value = v->value;
        v->key = u->key;
        v->value = u->value;
        u->key = temp_key;
        u->value = temp_value;

        // recursion is fine here; as it would be at most two calls deep
        om_delete_node(tree, u);
    }
}

/*
    Removes a key from the map and return true if the key exists and is deleted,
    false otherwise.
*/
bool om_delete_key(om_map_t *tree, om_key_t *key)
//@requires __om_is_valid_tree(tree);
//@ensures __om_is_valid_tree(tree);
{
    om_node_t *node = om_find_node(tree->root, key);
    if (node == NULL) return false;

    om_delete_node(tree, node);
    return true;
}

void om_print_kv_pair(om_node_t *kv) {
    printf("(%c) [", kv->is_red ? 'r' : 'b');
    for (int i = 0; i < kv->key->key_size; i++) {
        printint(kv->key->key[i]);
        if (i != kv->key->key_size - 1) printchar(' ');
    }
    printf("] %d\n", kv->value);
}

void om_print_map_preorder(om_node_t *node) {
    if (node == NULL) return;

    om_print_kv_pair(node);
    om_print_map_preorder(node->left);
    om_print_map_preorder(node->right);
}

void om_print_map_inorder(om_node_t *node) {
    if (node == NULL) return;

    om_print_map_preorder(node->left);
    om_print_kv_pair(node);
    om_print_map_preorder(node->right);
}

void om_print_map_postorder(om_node_t *node) {
    if (node == NULL) return;

    om_print_map_preorder(node->left);
    om_print_map_preorder(node->right);
    om_print_kv_pair(node);
}

void om_print_map(om_map_t *tree)
//@requires __om_is_valid_tree(tree);
{
    print("Map Size: ");
    printint(tree->size);
    println("");

    println("Pre Order:");
    om_print_map_preorder(tree->root);

    println("In Order:");
    om_print_map_inorder(tree->root);

    println("Post Order:");
    om_print_map_postorder(tree->root);
}

int main() {
    om_map_t *map = om_create_map();

    om_insert_s(map, "algorithm", 1);
    om_insert_s(map, "cmu", 2);
    om_insert_s(map, "code", 3);
    om_insert_s(map, "compute", 4);
    om_insert_s(map, "data", 5);
    om_insert_s(map, "database", 6);
    om_insert_s(map, "graph", 7);
    om_insert_s(map, "hello", 8);
    om_insert_s(map, "internet", 9);
    om_insert_s(map, "keyboard", 10);
    om_insert_s(map, "language", 11);
    om_insert_s(map, "laptop", 12);
    om_insert_s(map, "main", 13);
    om_insert_s(map, "monitor", 14);
    om_insert_s(map, "mouse", 15);
    om_insert_s(map, "network", 16);
    om_insert_s(map, "security", 17);
    om_insert_s(map, "tree", 18);
    om_insert_s(map, "website", 19);
    om_insert_s(map, "world", 20);

    om_delete_key(map, om_serialize_string("code"));
    om_delete_key(map, om_serialize_string("database"));
    om_delete_key(map, om_serialize_string("tree"));
    om_delete_key(map, om_serialize_string("network"));
    om_delete_key(map, om_serialize_string("keyboard"));
    om_delete_key(map, om_serialize_string("monitor"));
    om_delete_key(map, om_serialize_string("main"));
    om_delete_key(map, om_serialize_string("hello"));
    om_delete_key(map, om_serialize_string("algorithm"));
    om_delete_key(map, om_serialize_string("internet"));
    om_delete_key(map, om_serialize_string("mouse"));
    om_delete_key(map, om_serialize_string("graph"));
    om_delete_key(map, om_serialize_string("language"));
    om_delete_key(map, om_serialize_string("compute"));
    om_delete_key(map, om_serialize_string("security"));
    om_delete_key(map, om_serialize_string("cmu"));
    om_delete_key(map, om_serialize_string("website"));
    om_delete_key(map, om_serialize_string("data"));
    om_delete_key(map, om_serialize_string("laptop"));
    om_delete_key(map, om_serialize_string("hello"));

    //om_print_map(map);
    printf("%d\n", map->root->value);

    return 0;
}
