#use <conio>
#use <string>

#use "str_helper.c0"

struct reader_t {
    int length;
    int curr_pos;
    string content;
};
typedef struct reader_t reader_t;

struct token_t {
    /*
        0: lexer error
        1: keyword
        2: identifier
        3: operator
        4: symbols
        5: literals
    */
    int type;
    string token;
};
typedef struct token_t token_t;

bool r_eof(reader_t *reader) {
    return reader->curr_pos == reader->length;
}

char r_peek_char(reader_t *reader)
//@requires reader->curr_pos < reader->length;
{
    return string_charat(reader->content, reader->curr_pos);
}

void r_next_char(reader_t *reader)
//@requires reader->curr_pos + 1 <= reader->length;
{
    reader->curr_pos++;
}

void r_trim(reader_t *reader) {
    while (!r_eof(reader) && str_is_whitespace(r_peek_char(reader))) {
        r_next_char(reader);
    }
}

bool l_next_token(reader_t *reader, token_t *tok)
{   
    // identifier & keyword
    //if ()
    return true;
}

int l_lex(reader_t *reader, token_t[] tokens) {
    int n_tokens = 0;

    r_trim(reader);
    while (!r_eof(reader)) {
        token_t *tok = alloc(token_t);
        if (!l_next_token(reader, tok)) return -1;

        tokens[n_tokens].type = tok->type;
        tokens[n_tokens].token = tok->token;
        n_tokens++;
    }

    return n_tokens;
}

int main() {
    
    return 69;
}
