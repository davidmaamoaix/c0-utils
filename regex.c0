#use <conio>
#use <string>

/*
    Walmart version of a regex matcher. Only supports the following regex:
        - character classes (e.g. '[a-zA-Z0-9_]', '[^a-z]')
        - choice '|'
        - match any '.'
        - match one or more '+'
        - match any times '*'
        - optional '?'
        - shorthands '\d', '\D', '\w', '\W', '\s', '\S'
    (TODO: do the "match m-n occurences" thing)

    Some notes:
        - shorthands and escaped characters should be typed with two backslashes
        like: '\\d', '\\?' (one backslash isn't valid C0 syntax for character
        literals)
        - special characters such as '\t', '\n' and '\r' uses one backslash (as
        C0 supports them)
        - all quantifiers are greedy
        - everything only works on ASCII inputs
        - capturing group also doesn't exist (parentheses are used for operator
        precedence only)
*/

struct re_state_t;

struct re_edge_t {
    bool is_epsilon;
    struct re_state_t *target;
    bool[] bucket_set;
};
typedef struct re_edge_t re_edge_t;

struct re_state_t {
    int state_id;
    bool is_term_state;
    int n_edges;
    re_edge_t[] edges;
};
typedef struct re_state_t re_state_t;

struct re_ctx_t {
    int pc;
    string regex;
    int n_states;
    // bool is_dummy; // used for debugging
};
typedef struct re_ctx_t re_ctx_t;

struct re_regex_t {
    int n_states;
    re_state_t *head;
};
typedef struct re_regex_t re_regex_t;

bool re_parse_or(re_ctx_t *ctx, re_state_t *s, re_state_t *e);
bool re_parse_seq(re_ctx_t *ctx, re_state_t *s, re_state_t *e);
bool re_parse_term(re_ctx_t *ctx, re_state_t *s, re_state_t *e);
bool re_parse_atom(re_ctx_t *ctx, re_state_t *s, re_state_t *e);
bool re_parse_class(re_ctx_t *ctx, re_state_t *s, re_state_t *e);

re_state_t *re_new_state(re_ctx_t *ctx, bool is_term_state) {
    re_state_t *state = alloc(re_state_t);
    state->state_id = ctx->n_states;
    ctx->n_states++;
    state->is_term_state = is_term_state;
    state->n_edges = 0;
    state->edges = alloc_array(re_edge_t, 64);

    return state;
}

re_ctx_t *re_clone_ctx(re_ctx_t *real_ctx) {
    re_ctx_t *clone = alloc(re_ctx_t);
    clone->n_states = 0;
    clone->regex = real_ctx->regex;
    clone->pc = real_ctx->pc;
    // clone->is_dummy = real_ctx->is_dummy;
    return clone;
}

bool re_eof_ctx(re_ctx_t *ctx)
//@requires ctx->pc <= string_length(ctx->regex);
{
    return ctx->pc == string_length(ctx->regex);
}

char re_peek_ctx(re_ctx_t *ctx)
//@requires !re_eof_ctx(ctx);
{
    return string_charat(ctx->regex, ctx->pc);
}

bool re_is_sep_char(re_ctx_t *ctx)
//@requires ctx->pc <= string_length(ctx->regex);
{
    if (re_eof_ctx(ctx)) return true;

    char peek = re_peek_ctx(ctx);
    return peek == ')' || peek == '|';
}

bool re_consume(char expect, re_ctx_t *ctx)
//@requires ctx->pc <= string_length(ctx->regex);
{
    // explicit check for more explicit error message (thus the loose @requires)
    if (re_eof_ctx(ctx)) {
        println("Regex Syntax Error: unexpected end of input");
        return false;
    }

    char peek = re_peek_ctx(ctx);
    bool match = peek == expect;
    if (match) ctx->pc++;
    else {
        print("Regex Syntax Error: unexpected character '");
        printchar(peek);
        print("', expecting '");
        printchar(expect);
        println("'");
    }

    return match;
}

void re_add_epsilon(re_state_t *s, re_state_t *e) {
    s->edges[s->n_edges].is_epsilon = true;
    s->edges[s->n_edges].target = e;
    s->n_edges++;
}

bool re_parse_class(re_ctx_t *ctx, re_state_t *s, re_state_t *e) {
    return false;
}

bool re_parse_atom(re_ctx_t *ctx, re_state_t *s, re_state_t *e)
//@requires !re_eof_ctx(ctx);
{
    char peek = re_peek_ctx(ctx);
    if (peek == '(') {
        ctx->pc++;
        if (!re_parse_or(ctx, s, e)) return false;
        if (!re_consume(')', ctx)) return false;
    } else if (peek == '[') {
        // TODO: do the class thingy
    } else if (peek == '?' || peek == '+' || peek == '*') {
        println("Regex Syntax Error: misplaced '?', '*' or '+'");
        return false;
    } else {
        ctx->pc++;
        if (peek == '\\') {
            peek = re_peek_ctx(ctx);
            // TODO: add special characters such as '\d', ''
            if (
                peek != '+' && peek != '.' && peek != '*' &&
                peek != '?' && peek != '|' && peek != '\\' &&
                peek != '(' && peek != ')' && peek != '[' &&
                peek != ']'
            ) {
                print("Regex Syntax Error: invalid escaped char '\\");
                printchar(peek);
                println("'");
                return false;
            }
            ctx->pc++;
        }

        s->edges[s->n_edges].bucket_set = alloc_array(bool, 128);
        s->edges[s->n_edges].bucket_set[char_ord(peek)] = true;
        s->edges[s->n_edges].target = e;
        s->n_edges++;
    }

    return true;
}

// term := group | group postfix
bool re_parse_term(re_ctx_t *ctx, re_state_t *s, re_state_t *e)
//@requires !re_eof_ctx(ctx);
{
    // in case of '+', the same edge needs to be generated twice
    re_ctx_t *dummy_ctx = re_clone_ctx(ctx);
    // dummy_ctx->is_dummy = true;
    re_state_t *dummy_s = re_new_state(dummy_ctx, false);
    re_state_t *dummy_e = re_new_state(dummy_ctx, false);
    if (!re_parse_atom(dummy_ctx, dummy_s, dummy_e)) return false;

    if (re_eof_ctx(dummy_ctx)) {
        return re_parse_atom(ctx, s, e);
    }

    char peek = re_peek_ctx(dummy_ctx);
    if (peek == '?') {
        re_add_epsilon(s, e);
        if (!re_parse_atom(ctx, s, e)) return false;
        ctx->pc++;
    } else if (peek == '+') {
        re_state_t *interm = re_new_state(ctx, false);

        int pc_store = ctx->pc;
        if (!re_parse_atom(ctx, s, interm)) return false;
        ctx->pc = pc_store;
        if (!re_parse_atom(ctx, interm, interm)) return false;

        re_add_epsilon(interm, e);
        ctx->pc++;
    } else if (peek == '*') {
        re_state_t *interm = re_new_state(ctx, false);
        if (!re_parse_atom(ctx, interm, interm)) return false;
        
        re_add_epsilon(s, interm);
        re_add_epsilon(interm, e);
        ctx->pc++;
    } else {
        if(!re_parse_atom(ctx, s, e)) return false;
    }

    return true;
}

// seq := term | term seq | ''
bool re_parse_seq(re_ctx_t *ctx, re_state_t *s, re_state_t *e)
//@requires ctx->pc <= string_length(ctx->regex);
{
    if (re_is_sep_char(ctx)) {
        re_add_epsilon(s, e);
        return true;
    }
    
    // ugly backtracking to eliminate one unnecessary epsilon transition
    re_ctx_t *dummy_ctx = re_clone_ctx(ctx);
    // dummy_ctx->is_dummy = true;
    re_state_t *dummy_s = re_new_state(dummy_ctx, false);
    re_state_t *dummy_e = re_new_state(dummy_ctx, false);
    if (!re_parse_term(dummy_ctx, dummy_s, dummy_e)) return false;

    if (re_is_sep_char(dummy_ctx)) {
        return re_parse_term(ctx, s, e);
    } else {
        re_state_t *next = re_new_state(ctx, false);
        return re_parse_term(ctx, s, next) && re_parse_seq(ctx, next, e);
    }
}

// or := seq | seq '|' or
bool re_parse_or(re_ctx_t *ctx, re_state_t *s, re_state_t *e)
//@requires ctx->pc <= string_length(ctx->regex);
{
    if (!re_parse_seq(ctx, s, e)) return false;
    while (!re_eof_ctx(ctx) && re_peek_ctx(ctx) == '|') {
        ctx->pc++;
        if (!re_parse_seq(ctx, s, e)) return false;
    }

    return true;
}

re_regex_t *re_parse_regex(string regex) {
    re_ctx_t *ctx = alloc(re_ctx_t);
    ctx->n_states = 0;
    ctx->pc = 0;
    ctx->regex = regex;
    re_state_t *start = re_new_state(ctx, false);
    re_state_t *end = re_new_state(ctx, true);

    if (!re_parse_or(ctx, start, end)) {
        return NULL;
    }

    if (!re_eof_ctx(ctx)) {
        print("Regex Syntax Error: parse ended at char ");
        printint(ctx->pc);
        printchar('\n');
        return NULL;
    }

    re_regex_t *dfa = alloc(re_regex_t);
    dfa->n_states = ctx->n_states;
    dfa->head = start;

    return dfa;
}

void re_print_char(int ord) {
    if (ord == 128) {
        // 128 reserved for epsilon
        print("<epsilon>");
    } else {
        char chr = char_chr(ord);
        if (chr == ' ') print("<space>");
        else if (chr == '\t') print("<tab>");
        else if (chr == '\n') print("<br>");
        else printchar(chr);
    }
}

void re_print_state(re_state_t *state, bool[] visited, int n_states) {
    if (visited[state->state_id]) return;
    visited[state->state_id] = true;

    print("State ");
    printint(state->state_id);
    if (state->is_term_state) print(" (FINISH)");
    println(":");

    if (state->n_edges == 0) {
        println("\t(No out-going transitions)");
    } else {
        bool[] state_bucket = alloc_array(bool, n_states);
        bool[][] trans_bucket = alloc_array(bool[], n_states);

        for (int i = 0; i < state->n_edges; i++) {
            int to = state->edges[i].target->state_id;
            if (!state_bucket[to]) {
                state_bucket[to] = true;
                // 128 ASCII + 1 reserved for epsilon
                trans_bucket[to] = alloc_array(bool, 129);
            }

            if (state->edges[i].is_epsilon) {
                trans_bucket[to][128] = true;
            } else {
                for (int chr = 0; chr < 128; chr++) {
                    if (state->edges[i].bucket_set[chr]) {
                        trans_bucket[to][chr] = true;
                    }
                }
            }
        }

        for (int i = 0; i < n_states; i++) {
            if (state_bucket[i]) {
                print("\tState ");
                printint(i);
                print(": ");
                for (int chr = 0; chr < 129; chr++) {
                    if (trans_bucket[i][chr]) {
                        re_print_char(chr);
                        print(" ");
                    }
                }

                println("");
            }
        }
    }

    println("");
    for (int i = 0; i < state->n_edges; i++) {
        re_print_state(state->edges[i].target, visited, n_states);
    }
}

void re_print_dfa(re_regex_t *re) {
    print("Printing DFA with ");
    printint(re->n_states);
    println(" States");

    bool[] visited = alloc_array(bool, re->n_states);
    re_print_state(re->head, visited, re->n_states);

    println("END OF DFA");
}

int main() {
    // TODO: parse error on single char before '|'
    re_regex_t *re = re_parse_regex("a*|b*|d");
    print("Parse successful: ");
    printbool(re != NULL);
    printchar('\n');
    re_print_dfa(re);

    return 69;
}
