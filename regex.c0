#use <conio>
#use <string>

/*
    Walmart version of a regex matcher. Only supports the following regex:
        - character classes (e.g. '[a-zA-Z0-9_]', '[^a-z]')
        - choice '|'
        - match any '.'
        - match one or more '+'
        - match any times '*'
        - optional '?'
    (TODO: do the "match m-n occurences" thing)

    Some notes:
        - all quantifiers are greedy
        - everything only works on ASCII inputs
        - capturing group also doesn't exist (parentheses are used for operator
        precedence only)
*/

struct re_state_t;

struct re_edge_t {
    bool is_epsilon;
    struct re_state_t *target;
    bool[] bucket_set;
};
typedef struct re_edge_t re_edge_t;

struct re_state_t {
    bool is_term_state;
    int n_edges;
    re_edge_t[] edges;
};
typedef struct re_state_t re_state_t;

bool re_parse_or(string regex, int *pc, re_state_t *s, re_state_t *e);
bool re_parse_seq(string regex, int *pc, re_state_t *s, re_state_t *e);
bool re_parse_term(string regex, int *pc, re_state_t *s, re_state_t *e);
bool re_parse_group(string regex, int *pc, re_state_t *s, re_state_t *e);

re_state_t *re_new_state(bool is_term_state) {
    re_state_t *state = alloc(re_state_t);
    state->is_term_state = is_term_state;
    state->n_edges = 0;
    state->edges = alloc_array(re_edge_t, 64);

    return state;
}

bool re_is_sep_char(string regex, int *pc)
//@requires *pc <= string_length(regex);
{
    if (*pc == string_length(regex)) return true;

    char peek = string_charat(regex, *pc);
    return peek == ')' || peek == '|';
}

bool re_consume(char expect, string regex, int *pc)
//@requires *pc < string_length(regex);
{
    bool match = string_charat(regex, *pc) == expect;
    if (match) (*pc)++;
    return match;
}

void re_add_epsilon(re_state_t *s, re_state_t *e) {
    s->edges[s->n_edges].is_epsilon = true;
    s->edges[s->n_edges].target = e;
    s->n_edges++;
}

bool re_parse_group(string regex, int *pc, re_state_t *s, re_state_t *e)
//@requires *pc < string_length(regex);
{
    char peek = string_charat(regex, *pc);
    if (peek == '(') {
        (*pc)++;
        if (!re_parse_or(regex, pc, s, e)) return false;
        if (!re_consume(')', regex, pc)) return false;
    } else if (peek == '[') {
        // TODO: do the class thingy
    } else {
        (*pc)++;
        if (peek == '\\') {
            peek = string_charat(regex, *pc);
            (*pc)++;
        }

        s->edges[s->n_edges].bucket_set = alloc_array(bool, 128);
        s->edges[s->n_edges].bucket_set[char_ord(peek)] = true;
        s->n_edges++;
    }

    return false;
}

// term := group | group postfix
bool re_parse_term(string regex, int *pc, re_state_t *s, re_state_t *e)
//@requires *pc < string_length(regex);
{
    // in case of '+', the same edge needs to be generated twice
    int pc_store = *pc;
    if (!re_parse_group(regex, pc, s, e)) return false;

    if (*pc == string_length(regex)) return true;
    char peek = string_charat(regex, *pc);
    if (peek == '?') {
        re_add_epsilon(s, e);
        (*pc)++;
    } else if (peek == '+') {
        *pc = pc_store;
        if (!re_parse_group(regex, pc, e, e)) return false;
        (*pc)++;
    } else if (peek == '*') {
        *pc = pc_store;
        if (!re_parse_group(regex, pc, e, e)) return false;
        re_add_epsilon(s, e);
        (*pc)++;
    }

    return true;
}

// seq := term | term seq | ''
bool re_parse_seq(string regex, int *pc, re_state_t *s, re_state_t *e)
//@requires *pc <= string_length(regex);
{
    if (re_is_sep_char(regex, pc)) {
        re_add_epsilon(s, e);
        return true;
    }

    re_state_t *next = re_new_state(false);
    if (!re_parse_term(regex, pc, s, next)) return false;

    return re_parse_seq(regex, pc, next, e);
}

// or := seq | seq '|' or
bool re_parse_or(string regex, int *pc, re_state_t *s, re_state_t *e)
//@requires *pc <= string_length(regex);
{
    if (!re_parse_seq(regex, pc, s, e)) return false;
    while (*pc < string_length(regex) && string_charat(regex, *pc) == '|') {
        (*pc)++;
        if (!re_parse_seq(regex, pc, s, e)) return false;
    }

    return true;
}

re_state_t *re_parse_regex(string regex) {
    re_state_t *start = re_new_state(false);
    re_state_t *end = re_new_state(true);

    int *pc = alloc(int);
    if (!re_parse_or(regex, pc, start, end) || *pc != string_length(regex)) {
        return NULL;
    }
    return start;
}

int main() {
    string a = "";
    return 69;
}
